{"ast":null,"code":"import { API_BASE_URL, Views, User } from \"./constants\";\n/**\n * @desc Gets the existing contract information from database. If none, allow an Omega User create one.\n */\n\nfunction fetchContractInformation() {\n  fetch(`${API_BASE_URL}/contract-information`).then(response => response.json()).then(async data => {\n    let newView = !data.isContract ? Views.OMEGA_LOG_IN : Views.CONNECT_ACCOUNT;\n    this.setState({\n      view: newView,\n      user: newView === Views.OMEGA_LOG_IN ? User.OMEGA_USER : User.NORMAL_USER,\n      contract: data.isContract ? data.contract.contract : this.state.contract,\n      contractAddress: data.isContract ? data.contract.address : this.state.contractAddress\n    });\n  }).catch(e => {\n    // If no response is gotten from API service, try connecting again.\n    this.fetchContractInformation();\n  });\n}\n/**\n * @desc This handles the event triggered when an omega user attempts to log in.\n * @param {*} event \n */\n\n\nfunction handleOmegaLogInSubmit(event) {\n  // prevents the refreshing of the page\n  event.preventDefault();\n  let username = this.state.omegaUsername;\n  let password = this.state.omegaPassword;\n  const options = {\n    method: \"POST\",\n    headers: {\n      \"Content-type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      username,\n      password\n    })\n  };\n  fetch(`${API_BASE_URL}/admin/log-in`, options).then(response => response.json()).then(data => {\n    if (data.status === 'success') {\n      this.setState({\n        view: Views.CONNECT_ACCOUNT,\n        canLogOut: true,\n        omegaDetailsAreCorrect: true,\n        omegaUsername: '',\n        omegaPassword: ''\n      });\n    } else {\n      this.setState({\n        omegaDetailsAreCorrect: false\n      });\n    }\n  }).catch(e => {\n    this.setState({\n      view: Views.INDEX_VIEW\n    });\n  });\n}\n/**\n * @desc This handles the event triggered when an omega user enters their username or password\n * @param {*} event \n */\n\n\nfunction handleOmegaInputChange(event) {\n  this.setState({\n    [event.target.name]: event.target.value,\n    omegaDetailsAreCorrect: true\n  });\n}\n/**\n * @desc This handles the event triggered when a normal user enters their username or password\n * @param {*} event \n */\n\n\nfunction handleNormalUserInputChange(event) {\n  let numberOfTokens, priceOfTokens;\n\n  if (event.target.name === 'numberOfTokens') {\n    numberOfTokens = event.target.value;\n    priceOfTokens = numberOfTokens === 0 ? 0 : numberOfTokens * this.state.price;\n  }\n\n  if (event.target.name === 'priceOfTokens') {\n    priceOfTokens = event.target.value;\n    numberOfTokens = priceOfTokens === 0 ? 0 : priceOfTokens / this.state.price;\n  }\n\n  if (priceOfTokens > this.state.reach.balanceOf(this.state.account) || numberOfTokens > this.state.supply) {} else {\n    this.setState({\n      [event.target.name]: event.target.value\n    });\n  }\n}\n/**\n * @desc This triggers a log out of the omega user.\n */\n\n\nfunction handleLogOut() {\n  fetch(`${API_BASE_URL}/admin/log-out`).then(response => response.json()).then(data => {\n    this.setState({\n      view: Views.INDEX_VIEW,\n      canLogOut: false\n    });\n    this.fetchContractInformation();\n  }).catch(e => {\n    this.handleLogOut();\n  });\n}\n/**\n * @desc Connect to crypto account\n */\n\n\nasync function connectDefaultAccount() {\n  try {\n    let acct = await this.state.reach.getDefaultAccount();\n    let currentView = this.state.user === User.OMEGA_USER ? Views.CREATE_CONTRACT : Views.BUY_TOKEN_VIEW;\n    this.setState({\n      account: acct,\n      hasDefaultAccount: true,\n      view: currentView\n    });\n    return true;\n  } catch (error) {\n    this.setState({\n      hasDefaultAccount: false\n    });\n    return false;\n  }\n}\n/**\n * This adds a new account to the application.\n * @param {*} account contract object to be added to application\n */\n\n\nfunction addAccount(account) {\n  let currentView = this.state.user === User.OMEGA_USER ? Views.CREATE_CONTRACT : Views.BUY_TOKEN_VIEW;\n  this.setState({\n    account: account,\n    view: currentView\n  });\n}\n\nasync function createContract() {\n  const interact = this.createParticipantInteractInterface();\n  /**\n   * @description displays amount of non-network tokens paid for by user and amount of network tokens it cost\n   * @param name Name of User that paid to contract\n   * @param amount Amount of tokens paid to contract \n   * @param price Price of non-network token\n   */\n\n  interact.paidBy = (name, amount, price, address) => {\n    console.log(`${name} of address: ${address} paid for ${amount} non-network tokens with ${this.formatCurrency(amount * price)} network tokens. `);\n  };\n\n  console.log('Creating new contract...');\n  const contract = this.state.account.deploy(this.state.backend);\n  console.log('Contract created successfully');\n  console.log(contract);\n  console.log('Communicating with back end...');\n  this.setState({\n    isLoading: true\n  });\n  contract.getInfo().then(info => {\n    this.setState({\n      contractAddress: JSON.stringify(info),\n      contract: contract\n    });\n    let obj = {\n      contract: JSON.stringify(contract),\n      address: JSON.stringify(info)\n    };\n    const options = {\n      method: \"POST\",\n      headers: {\n        \"Content-type\": \"application/json\"\n      },\n      body: JSON.stringify(obj)\n    };\n    console.log(options);\n    fetch(`${API_BASE_URL}/contract-information`, options).then(response => response.json()).then(data => {\n      console.log(data);\n    }).catch(err => {\n      console.log(err);\n    });\n  });\n\n  try {\n    await this.state.backend.OmegaUser(contract, interact); // const contractAddress = await contract.getInfo()\n    // console.log(contractAddress)\n    // this.setState({contractAddress: contractAddress})\n  } catch (e) {\n    console.error(e);\n    alert(\"Insufficied tokens in wallet to create contract\");\n  }\n}\n\nfunction createParticipantInteractInterface() {\n  let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  const interact = { ...this.state.reach.hasRandom\n  };\n  interact.name = name === \"\" ? \"Omega Man\" : name;\n\n  interact.acceptToken = async token => {\n    const tokenID = this.state.reach.bigNumberToNumber(token);\n    await this.state.account.tokenAccept(tokenID);\n  };\n  /**\n   * @description displays network token balance and non-network token balance\n   * @param tok Token datatype \n   */\n\n\n  interact.showBalance = async tok => {\n    // console.log(`Your balance is ${formatCurrency(await stdlib.balanceOf(accUser))} network tokens and ${formatCurrency(await stdlib.balanceOf(accUser, tok))} non-network tokens`);\n    console.log(`Your balance is ${this.formatCurrency(await this.state.reach.balanceOf(this.state.account))} network tokens and ${this.formatCurrency(this.state.reach.parseCurrency(await this.state.reach.balanceOf(this.state.account, tok)))} non-network tokens`);\n  };\n  /**\n   * @description Displays details of the token on the console\n   * @param supply amount of non-network token available in the contract\n   * @param price price of one non-network token with respect to network token\n   */\n\n\n  interact.displayTokenDetails = (supply, price) => {\n    console.log(supply);\n    console.log(`price: ${price}`);\n    console.log(`Amount of tokens remaining: ${supply} \\nPrice of Token: ${this.formatCurrency(price)}`);\n    this.setState({\n      supply: supply,\n      price: this.formatCurrency(price)\n    });\n  };\n\n  return interact;\n}\n/**\n * @desc Connect to contract with account of normal user.\n */\n\n\nasync function connectToContract() {\n  const contractAddress = this.state.contractAddress;\n  console.log(`contract address to connect to: ${contractAddress}`);\n  const account = this.state.account;\n  console.log(`account we are to connect to contract with: ${account.getAddress()}`);\n  console.log(`Connecting to contract`);\n  const contract = account.contract(this.state.backend, JSON.parse(contractAddress));\n  console.log(`Connected successfully.`);\n  console.log(`Waiting for response from backend`);\n  const interact = this.createParticipantInteractInterface();\n  /**\n   * @description Asks user if they want to buy a no-network token, then asks for how much of it they want\n   * @returns Number of non-network tokens user wants to buy\n   */\n\n  interact.buyToken = async (supply, tokenPrice) => {\n    console.log('Interacting');\n    const balance = this.formatCurrency(await this.state.reach.balanceOf(this.state.account));\n    const price = this.formatCurrency(tokenPrice);\n    this.setState({\n      price: price,\n      supply: supply\n    });\n    console.log(\"We waiting here\");\n    let numberOfToks = await this.getUserResponse();\n    numberOfToks = this.state.reach.parseCurrency(numberOfToks);\n    console.log(\"Made it to the other side\");\n    console.log(`number of tokens: ${numberOfToks}`);\n    return [numberOfToks, this.state.account.networkAccount]; // while (true) {\n    //   numberOfToks = willBuy ? await ask(`How many non-network tokens would you like to buy?`, x => fmt(stdlib.parseCurrency(x))) : 0\n    //   if (numberOfToks * price > balance) {\n    //     console.log(`You do not have enough tokens for this transaction. Please don't try to bite more than you can chew`)\n    //     continue\n    //   } else {\n    //     if (numberOfToks > supply) {\n    //       console.log(`You're asking for more tokens than are available. Check the amount of tokens then adjust your demand`)\n    //       continue\n    //     } else {\n    //       break\n    //     }\n    //   }\n    // }\n  };\n\n  this.state.backend.NormalUser(contract, interact);\n}\n\nfunction buyToken(event) {\n  event.preventDefault();\n\n  if (this.state.numberOfTokens > this.state.supply) {\n    alert(`You're asking for more tokens than are available. Check the amount of tokens then adjust your demand`);\n  } else if (this.state.priceOfTokens > this.state.reach.balanceOf(this.state.account)) {\n    alert(`You do not have enough tokens for this transaction. Please don't try to bite more than you can chew`);\n  } else {\n    this.resolved(this.state.numberOfTokens);\n  }\n}\n/**\n * @description Formats the currency amount to 4 decimal places.\n * @param amount Amount of currency to be formatted.\n * @returns Formatted number.\n */\n\n\nfunction formatCurrency(amount) {\n  return this.state.reach.formatCurrency(amount, 8);\n}\n\nexport { fetchContractInformation, handleOmegaInputChange, handleOmegaLogInSubmit, handleLogOut, connectDefaultAccount, addAccount, createContract, createParticipantInteractInterface, formatCurrency, connectToContract, handleNormalUserInputChange, buyToken };","map":{"version":3,"sources":["/home/paradoxfly/reach/bonding-curve-sale/src/utils/functions.js"],"names":["API_BASE_URL","Views","User","fetchContractInformation","fetch","then","response","json","data","newView","isContract","OMEGA_LOG_IN","CONNECT_ACCOUNT","setState","view","user","OMEGA_USER","NORMAL_USER","contract","state","contractAddress","address","catch","e","handleOmegaLogInSubmit","event","preventDefault","username","omegaUsername","password","omegaPassword","options","method","headers","body","JSON","stringify","status","canLogOut","omegaDetailsAreCorrect","INDEX_VIEW","handleOmegaInputChange","target","name","value","handleNormalUserInputChange","numberOfTokens","priceOfTokens","price","reach","balanceOf","account","supply","handleLogOut","connectDefaultAccount","acct","getDefaultAccount","currentView","CREATE_CONTRACT","BUY_TOKEN_VIEW","hasDefaultAccount","error","addAccount","createContract","interact","createParticipantInteractInterface","paidBy","amount","console","log","formatCurrency","deploy","backend","isLoading","getInfo","info","obj","err","OmegaUser","alert","hasRandom","acceptToken","token","tokenID","bigNumberToNumber","tokenAccept","showBalance","tok","parseCurrency","displayTokenDetails","connectToContract","getAddress","parse","buyToken","tokenPrice","balance","numberOfToks","getUserResponse","networkAccount","NormalUser","resolved"],"mappings":"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","sourcesContent":["import { API_BASE_URL, Views, User } from \"./constants\";\n\n/**\n * @desc Gets the existing contract information from database. If none, allow an Omega User create one.\n */\nfunction fetchContractInformation() {\n  fetch(`${API_BASE_URL}/contract-information`)\n    .then(response => response.json())\n    .then(async data => {\n      let newView = !data.isContract ? Views.OMEGA_LOG_IN : Views.CONNECT_ACCOUNT\n      \n      this.setState({ \n        view: newView, \n        user: newView === Views.OMEGA_LOG_IN? User.OMEGA_USER : User.NORMAL_USER,\n        contract: data.isContract? data.contract.contract : this.state.contract,\n        contractAddress: data.isContract? data.contract.address : this.state.contractAddress\n      })\n    })\n    .catch(e => {\n      // If no response is gotten from API service, try connecting again.\n      this.fetchContractInformation()\n    })\n}\n\n/**\n * @desc This handles the event triggered when an omega user attempts to log in.\n * @param {*} event \n */\nfunction handleOmegaLogInSubmit(event) {\n  // prevents the refreshing of the page\n  event.preventDefault();\n\n  let username = this.state.omegaUsername;\n  let password = this.state.omegaPassword;\n\n  const options = {\n    method: \"POST\",\n    headers: {\n      \"Content-type\": \"application/json\"\n    },\n    body: JSON.stringify({ username, password }),\n  }\n\n  fetch(`${API_BASE_URL}/admin/log-in`, options)\n    .then(response => response.json())\n    .then(data => {\n      if (data.status === 'success') {\n        this.setState({ view: Views.CONNECT_ACCOUNT, canLogOut: true, omegaDetailsAreCorrect: true, omegaUsername: '', omegaPassword: '' })\n      } else {\n        this.setState({ omegaDetailsAreCorrect: false })\n      }\n    })\n    .catch(e => {\n      this.setState({ view: Views.INDEX_VIEW })\n    })\n}\n\n/**\n * @desc This handles the event triggered when an omega user enters their username or password\n * @param {*} event \n */\nfunction handleOmegaInputChange(event) {\n  this.setState({ [event.target.name]: event.target.value, omegaDetailsAreCorrect: true })\n}\n\n/**\n * @desc This handles the event triggered when a normal user enters their username or password\n * @param {*} event \n */\n function handleNormalUserInputChange(event) {\n   let numberOfTokens, priceOfTokens\n   if(event.target.name === 'numberOfTokens') {\n      numberOfTokens = event.target.value;\n      priceOfTokens = numberOfTokens === 0? 0 : numberOfTokens * this.state.price\n   }\n\n   if (event.target.name === 'priceOfTokens') {\n      priceOfTokens = event.target.value;\n      numberOfTokens = priceOfTokens === 0 ? 0 : priceOfTokens / this.state.price\n   }\n\n   if(priceOfTokens > this.state.reach.balanceOf(this.state.account)  || numberOfTokens > this.state.supply){\n\n   } else {\n    this.setState({ [event.target.name]: event.target.value })\n   }\n  \n}\n\n/**\n * @desc This triggers a log out of the omega user.\n */\nfunction handleLogOut() {\n  fetch(`${API_BASE_URL}/admin/log-out`)\n    .then(response => response.json())\n    .then(data => {\n      this.setState({ view: Views.INDEX_VIEW, canLogOut: false })\n      this.fetchContractInformation()\n    }).catch(e => {\n      this.handleLogOut()\n    })\n}\n\n/**\n * @desc Connect to crypto account\n */\nasync function connectDefaultAccount() {\n  try {\n    let acct = await this.state.reach.getDefaultAccount();\n    let currentView = this.state.user === User.OMEGA_USER? Views.CREATE_CONTRACT : Views.BUY_TOKEN_VIEW;\n    this.setState({ account: acct, hasDefaultAccount: true, view: currentView});\n    return true\n  }\n  catch (error) {\n    this.setState({ hasDefaultAccount: false })\n    return false\n  }\n\n}\n\n/**\n * This adds a new account to the application.\n * @param {*} account contract object to be added to application\n */\nfunction addAccount(account) {\n  let currentView = this.state.user === User.OMEGA_USER? Views.CREATE_CONTRACT : Views.BUY_TOKEN_VIEW;\n  this.setState({ account: account, view: currentView })\n}\n\nasync function createContract() {\n  const interact = this.createParticipantInteractInterface();\n\n  /**\n   * @description displays amount of non-network tokens paid for by user and amount of network tokens it cost\n   * @param name Name of User that paid to contract\n   * @param amount Amount of tokens paid to contract \n   * @param price Price of non-network token\n   */\n  interact.paidBy = (name, amount, price, address) => {\n    console.log(`${name} of address: ${address} paid for ${amount} non-network tokens with ${this.formatCurrency(amount * price)} network tokens. `)\n  }\n\n  console.log('Creating new contract...')\n  const contract = this.state.account.deploy(this.state.backend);\n  console.log('Contract created successfully')\n  console.log(contract)\n  console.log('Communicating with back end...')\n\n  this.setState({isLoading: true })\n\n  contract.getInfo().then(info => {\n    this.setState({contractAddress: JSON.stringify(info), contract: contract, })\n\n    let obj = {\n      contract: JSON.stringify(contract),\n      address: JSON.stringify(info)\n    }\n\n    const options = {\n      method: \"POST\",\n      headers: {\n        \"Content-type\": \"application/json\"\n      },\n      body: JSON.stringify(obj)\n    }\n\n    console.log(options)\n\n    fetch(`${API_BASE_URL}/contract-information`, options)\n    .then(response => response.json())\n    .then(data => {\n      console.log(data)\n    })\n    .catch(err => {\n      console.log(err)\n    })\n  })\n  \n  \n  try {\n    \n    await this.state.backend.OmegaUser(contract, interact)\n    // const contractAddress = await contract.getInfo()\n    // console.log(contractAddress)\n    // this.setState({contractAddress: contractAddress})\n  }\n  catch(e) {\n    console.error(e)\n    alert(\"Insufficied tokens in wallet to create contract\")\n  }\n}\n\nfunction createParticipantInteractInterface(name = \"\") {\n  const interact = { ...this.state.reach.hasRandom };\n  interact.name = name === \"\" ? \"Omega Man\" : name;\n\n  interact.acceptToken = async (token) => {\n    const tokenID = this.state.reach.bigNumberToNumber(token)\n    await this.state.account.tokenAccept(tokenID)\n  }\n\n  /**\n   * @description displays network token balance and non-network token balance\n   * @param tok Token datatype \n   */\n  interact.showBalance = async (tok) => {\n    // console.log(`Your balance is ${formatCurrency(await stdlib.balanceOf(accUser))} network tokens and ${formatCurrency(await stdlib.balanceOf(accUser, tok))} non-network tokens`);\n    console.log(`Your balance is ${this.formatCurrency(await this.state.reach.balanceOf(this.state.account))} network tokens and ${this.formatCurrency(this.state.reach.parseCurrency(await this.state.reach.balanceOf(this.state.account, tok)))} non-network tokens`);\n  }\n\n  /**\n   * @description Displays details of the token on the console\n   * @param supply amount of non-network token available in the contract\n   * @param price price of one non-network token with respect to network token\n   */\n  interact.displayTokenDetails = (supply, price) => {\n    console.log(supply)\n    console.log(`price: ${price}`)\n    console.log(`Amount of tokens remaining: ${supply} \\nPrice of Token: ${this.formatCurrency(price)}`)\n    this.setState({supply: supply, price: (this.formatCurrency(price))})\n  }\n\n  return interact\n}\n\n/**\n * @desc Connect to contract with account of normal user.\n */\nasync function connectToContract() {\n  const contractAddress = this.state.contractAddress\n  console.log(`contract address to connect to: ${contractAddress}`)\n\n  const account = this.state.account\n  console.log(`account we are to connect to contract with: ${account.getAddress()}`)\n\n  console.log(`Connecting to contract`)\n  const contract = account.contract(this.state.backend, JSON.parse(contractAddress))\n  console.log(`Connected successfully.`)\n  console.log(`Waiting for response from backend`)\n\n  const interact = this.createParticipantInteractInterface();\n\n  /**\n   * @description Asks user if they want to buy a no-network token, then asks for how much of it they want\n   * @returns Number of non-network tokens user wants to buy\n   */\n  interact.buyToken = async (supply, tokenPrice) => {\n    console.log('Interacting')\n    const balance = this.formatCurrency(await this.state.reach.balanceOf(this.state.account))\n    const price = this.formatCurrency(tokenPrice)\n\n    this.setState({price: price, supply: supply})\n\n    console.log(\"We waiting here\")\n    let numberOfToks = await this.getUserResponse()\n    numberOfToks = this.state.reach.parseCurrency(numberOfToks)\n    console.log(\"Made it to the other side\")\n    console.log(`number of tokens: ${numberOfToks}`)\n    \n    return [(numberOfToks), this.state.account.networkAccount]\n    // while (true) {\n    //   numberOfToks = willBuy ? await ask(`How many non-network tokens would you like to buy?`, x => fmt(stdlib.parseCurrency(x))) : 0\n    //   if (numberOfToks * price > balance) {\n    //     console.log(`You do not have enough tokens for this transaction. Please don't try to bite more than you can chew`)\n    //     continue\n    //   } else {\n    //     if (numberOfToks > supply) {\n    //       console.log(`You're asking for more tokens than are available. Check the amount of tokens then adjust your demand`)\n    //       continue\n    //     } else {\n          \n    //       break\n    //     }\n    //   }\n    // }\n  }\n\n  this.state.backend.NormalUser(contract, interact)\n}\n\nfunction buyToken(event) {\n  event.preventDefault()\n\n  if(this.state.numberOfTokens > this.state.supply){\n    alert(`You're asking for more tokens than are available. Check the amount of tokens then adjust your demand`)\n  }\n  else if (this.state.priceOfTokens > this.state.reach.balanceOf(this.state.account)) {\n    alert(`You do not have enough tokens for this transaction. Please don't try to bite more than you can chew`)\n  }\n  else {\n    this.resolved(this.state.numberOfTokens)\n  }\n}\n\n/**\n * @description Formats the currency amount to 4 decimal places.\n * @param amount Amount of currency to be formatted.\n * @returns Formatted number.\n */\n function formatCurrency(amount) {\n  return this.state.reach.formatCurrency(amount, 8);\n}\n\nexport {\n  fetchContractInformation,\n  handleOmegaInputChange,\n  handleOmegaLogInSubmit,\n  handleLogOut,\n  connectDefaultAccount,\n  addAccount,\n  createContract,\n  createParticipantInteractInterface,\n  formatCurrency,\n  connectToContract,\n  handleNormalUserInputChange,\n  buyToken\n}\n\n"]},"metadata":{},"sourceType":"module"}